---
title: "How Uncertain Are Your Random Forest Predictions?"
author: "Sarah Tan"
date: '`r Sys.Date()`'
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to surfin: A R package to perform statistical inference for random forests}
  %\VignetteEngine{knitr::rmarkdown} 
  %\VignetteEncoding{UTF-8}
---

This vignette demonstrates how to use the surfin R package to compute uncertainty for random forest predictions. We will compare the U-statistics based variance estimate ([Mentch & Hooker 2016](http://jmlr.org/papers/v17/14-168.html)) provided in this package with another estimate based on the infinitesimal jackknife ([Wager, Hastie, Efron, 2014](http://jmlr.org/papers/v15/wager14a.html)). The latter is provided in the R code [randomForestCI](https://github.com/swager/randomForestCI/) by the authors of the paper. For a discussion of the differences between these two variance estimates, see [Section 2.1 of Mentch et al.](http://jmlr.org/papers/volume17/14-168/14-168.pdf)

## Package Updates
Categorical predictors are currently converted to their numeric equivalents, not made into indicator variables. This feature is pending. If you have categorical predictors, for now, make them indicators before calling the forest function.

This package is actively under development. Feedback, bug reports, etc. are very much welcome! Find our contact info on the [package website](http://shftan.github.io/surfin/).

## Setup

Let's get started! First, load packages needed for this example:
```{r}
library(surfin)
library(devtools)  # to install randomForestCI package from github
library(randomForest)  # to compare forest implementations
library(rpart) # for kyphosis data
#library(MASS) # for Boston housing and breast cancer data
```

Next, install and load the [randomForestCI](https://github.com/swager/randomForestCI/) R package:
```{r}
install_github("swager/randomForestCI")
library(randomForestCI)
```

## Regression
We start with a regression example:
```{r}
#data(Boston)
#x = Boston[,1:(ncol(Boston)-1)]
#y = Boston[,ncol(Boston)]
x = cu.summary[,c("Price","Country","Reliability","Type")]
y = cu.summary$Mileage
keep = !is.na(y)
y = y[keep]
x = x[keep,]
keep = !apply(is.na(x),1,any)
y = y[keep]
x = x[keep,]
n = length(y)
train = sample(1:n,n*0.7)
test = setdiff(1:n,train)
xtrain = x[train,]
ytrain = y[train]
xtest = x[test,]
ytest = y[test]
```

To compute the U-statistics based variance estimate, we use sampling without replacement and specify B, the number of common observations between trees to be 20. To give an idea of what this means, if we use ntree=5000 trees and B=20 common observations between trees, L=5000/20 = 250 trees will share an observation, then the next 250 trees with share another observation, and so forth. So two of these three parameters can be specified, and the third will automatically follow.
```{r}
fit = forest(xtrain,ytrain,var.type="ustat",B=20,ntree=5000)
```

Check out what the forest object outputs:
```{r}
names(fit)
```

### Prediction 
There are a variety of prediction options to choose from:

1. On the train set using only out-of-bag train observations

2. On the train set using all train observations

3. On the test set using all test observations

```{r}
u_train_oob = fit$predicted        # Case (1)
u_train = predict(fit,xtrain)  # Case (2)
temp = predict(fit,xtest,individualTrees=T)   # Case (3)
u_test = temp$predicted
u_test_all = temp$predictedAll
temp = data.frame(u_train_oob,u_train)
head(temp)
head(u_test)
```

### U-statistics based variance estimate

We can calculate and plot the u-statistics based variance estimate on the test set (Case (2)):
```{r}
ustat = forest.varU(u_test_all,fit)
head(ustat)
plot(ustat)
```

It's also possible to retrieve not just the variance, but also covariance between predictions:
```{r}
temp = forest.varU(u_test_all,fit,covariance=TRUE)
y.hat = temp[[1]]
cov = temp[[2]]
dim(cov)
cov[1:6,1:6]
```
The (i,j) element in the covariance matrix represents the estimated covariance between observation i and observation j's predictions.

The diagonals of the covariance matrix are exactly the variances we saw above:
```{r}
unique(diag(cov) - ustat[,2])
```

We can also calculate variance estimate on the train set (Case (1)):
```{r}
ustat = forest.varU(fit$predictedAll,fit)
head(ustat)
plot(ustat)
```

### Infinitesimal jackknife based variance estimate

Now we compare to the infinitesimal jackknife based variance using the randomForestCI package:
```{r}
rf = randomForest(xtrain, ytrain, keep.inbag = TRUE, ntree=5000) 
ij = randomForestInfJack(rf, xtrain, calibrate = TRUE)
head(ij)
plot(ij)
```

Next we try calling the infinitesimal jackknife code in the randomForestCI package, but using our forest where sampling is performed with replacement:
```{r}
fit = forest(xtrain,ytrain,var.type="infjack",ntree=5000)
ij2_train_oob = fit$predicted   # Case (1)
ij2 = forest.varIJ(fit$predictedAll,fit)
head(ij2)
plot(ij2)
```

### Compare to randomForest package

Let's compare our forest's predictions to the predictions of the randomForest package:
```{r}
rf_train_oob = rf$predicted
plot(ij2_train_oob,rf_train_oob)
lines(ij2_train_oob,ij2_train_oob,lty="dashed")
```

### Sensitivity Analysis
Let's compare the variance estimates and see how they change when more trees are used in the forest:
```{r}
varU = vector("numeric")
varIJ = vector("numeric")
nts = seq(1000,10000,2000)
for (nt in nts)
{
  fit = forest(xtrain,ytrain,var.type="ustat",B=20,ntree=nt)
  varU = c(varU,mean(forest.varU(fit$predictedAll,fit)[,2]))
  rf = randomForest(xtrain, ytrain, keep.inbag = TRUE, ntree=nt) 
  varIJ = c(varIJ,mean(randomForestInfJack(rf, xtrain, calibrate = TRUE)[,2]))
}
plot(nts,varU,ylim=c(0,max(varU,varIJ)),cex.axis=0.6,ylab="Mean Est. Variance",xlab="Number of Trees",type="o",cex.lab=0.5)
points(nts,varIJ,col="blue",type="o")
legend("topright",legend=c("U-Stat","IJ"),col=c("black","blue"),lty="solid",cex=0.6)
print(varU)
print(varIJ)
```

We can also perform sensitivity analysis on the B parameter, the number of common observations between trees.
```{r}
varU = vector("numeric")
varIJ = vector("numeric")
bs = c(2,5,10,20,25)
for (b in bs)
{
  fit = forest(xtrain,ytrain,var.type="ustat",B=b,ntree=1000)
  varU = c(varU,mean(forest.varU(fit$predictedAll,fit)[,2]))
}
plot(bs,varU,ylim=c(0,max(varU,varIJ)),cex.axis=0.6,ylab="Mean Est. Variance",xlab="B",type="o",cex.lab=0.5)
print(varU)
```

## Binary Classification

Next, we try classification. Currently only binary classification is supported:
```{r}
#data(biopsy)
#x = biopsy[1:(ncol(biopsy)-1)]
#y = biopsy[,ncol(biopsy)]
x = kyphosis[,c("Age","Number","Start")]
y = kyphosis$Kyphosis
keep = !is.na(y)
y = y[keep]
x = x[keep,]
keep = !apply(is.na(x),1,any)
y = y[keep]
x = x[keep,]
n = length(y)
train = sample(1:n,n*0.7)
test = setdiff(1:n,train)
xtrain = x[train,]
ytrain = y[train]
xtest = x[test,]
ytest = y[test]
```

The response is rather imbalanced:
```{r}
table(y)
```

### Prediction

Like for regression, we have several options for prediction.
```{r}
fit = forest(xtrain,ytrain,var.type="ustat",B=20,ntree=5000)
names(fit)
u_train_oob = fit$predicted        # Case (1)
table(u_train_oob)
u_train = predict(fit,xtrain)  # Case (2)
table(u_train)
temp = predict(fit,xtest,individualTrees=T)   # Case (3)
u_test = temp$predicted
u_test_prob = temp$predictedProb
u_test_all = temp$predictedAll
table(u_test)
```

### U-statistics based variance estimate

Check out the test set variance estimate (Case (2)):
```{r}
ustat = forest.varU(u_test_all,fit)
head(ustat)
plot(ustat)
```

It's possible to look at the predicted probability of the classes, instead of class names:
```{r}
ustat = forest.varU(u_test_prob,fit)
head(ustat)
plot(ustat)
```

Now we look at the training set (Case (1)), both class names and probabilities:
```{r}
ustat = forest.varU(fit$predictedAll,fit)
head(ustat)
plot(ustat)
ustat = forest.varU(fit$predictedProb,fit)
head(ustat)
plot(ustat)
```

### Infinitesimal jackknife based variance estimate
Again we can compare to the infinitesimal jackknife: (looks like there is a bug in the [randomForestCI](https://github.com/swager/randomForestCI/) code (infinitesimalJackknife.R; line 144-145) in variance estimates for classification, so the code below is commented out until that package is fixed)
```{r}
#rf = randomForest(x, y, keep.inbag = TRUE)
#ij = randomForestInfJack(rf, x, calibrate = TRUE)
#head(ij)
#plot(ij)
```

Again we run the infinitesimal jackknife code in the randomForestCI package on our forest with sampling with replacement:
```{r}
fit = forest(xtrain,ytrain,var.type="infjack",ntree=5000)
ij2_train_oob = fit$predicted   # Case (1)
ij2 = forest.varIJ(fit$predictedAll,fit)
head(ij2)
plot(ij2)
```

### Compare to randomForest package

We end by comparing our forest's predictions to that of the randomForest package
```{r}
rf = randomForest(xtrain,ytrain,keep.forest=TRUE,keep.inbag=TRUE,replace=TRUE,ntree=5000)
rf_train_oob = rf$predicted
table(ij2_train_oob,rf_train_oob)
```

## Implementation Notes 

* Data with non-response, or classification with more than 2 categories is not yet supported. Contact us if you are eager for these!

* Categorical predictors are currently converted to their numeric equivalents, not made into indicator variables. This feature is pending. 

* Like the randomForest package, the splitting criterion for regression is mean squared error, and gini impurity for binary classification.

## Mathematical Notes
* Minimizing gini impurity in binary classification is equivalent to minimizing mean squared error. For example, taking $Y\in\{0,1\}$, it can be shown that MSE = $\frac{1}{2}$ Gini impurity.

## Some Intuition (to be fleshed out)
In a foundational paper, Breiman (2001) showed that a random forest's sampling variance (by which we mean ....) is determined by two factors: the variance of each tree in the forest, and the correlation between trees. Intuitively, having trees that are certain about their predictions and less correlated with each other means the forest is reasonably certain .

One of the parameters driving correlation between individual trees is how many features they share. Hence, the higher the proportion of features sampled by each tree, the higher the probability that trees have features in common. However, this same parameter also affects the variance of an individual tree - the less features a tree is allowed to use, the more uncertain its prediction. Hence, .... 